# -*- coding: utf-8 -*-
"""waterjug.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10qQQ37FBDAs2ZtLXAjFGuuHlJuL_Rgzo
"""

from collections import deque

def water_jug_solver(jug1_cap, jug2_cap, target):
    """
    Solves the Water Jug Problem using Breadth-First Search (BFS).

    Args:
        jug1_cap (int): Capacity of the first jug (Jug A).
        jug2_cap (int): Capacity of the second jug (Jug B).
        target (int): The target amount of water to measure.

    Returns:
        list: A list of tuples representing the steps to reach the goal,
              or None if the target is unreachable.
    """
    if target > jug1_cap + jug2_cap or target < 0:
        return None  # Target is impossible

    # Initial state: (0, 0)
    start_state = (0, 0)

    # Queue for BFS, storing (state, path_to_state)
    # A state is a tuple (water_in_jug1, water_in_jug2)
    queue = deque([(start_state, [start_state])])

    # Set to store visited states to avoid cycles and redundant work
    visited = {start_state}

    while queue:
        # Get the current state and the path taken to reach it
        current_state, path = queue.popleft()
        jug1, jug2 = current_state

        # Check if the goal is reached
        if jug1 == target or jug2 == target:
            return path

        # --- Generate Possible Next States (Transitions) ---

        # 1. Fill Jug 1
        next_state = (jug1_cap, jug2)
        if next_state not in visited:
            visited.add(next_state)
            new_path = path + [next_state]
            queue.append((next_state, new_path))

        # 2. Fill Jug 2
        next_state = (jug1, jug2_cap)
        if next_state not in visited:
            visited.add(next_state)
            new_path = path + [next_state]
            queue.append((next_state, new_path))

        # 3. Empty Jug 1
        next_state = (0, jug2)
        if next_state not in visited:
            visited.add(next_state)
            new_path = path + [next_state]
            queue.append((next_state, new_path))

        # 4. Empty Jug 2
        next_state = (jug1, 0)
        if next_state not in visited:
            visited.add(next_state)
            new_path = path + [next_state]
            queue.append((next_state, new_path))

        # 5. Pour Jug 1 to Jug 2
        # Amount to pour is the minimum of what's in Jug 1 and what Jug 2 can hold
        pour_amount = min(jug1, jug2_cap - jug2)
        next_jug1 = jug1 - pour_amount
        next_jug2 = jug2 + pour_amount
        next_state = (next_jug1, next_jug2)
        if next_state not in visited:
            visited.add(next_state)
            new_path = path + [next_state]
            queue.append((next_state, new_path))

        # 6. Pour Jug 2 to Jug 1
        # Amount to pour is the minimum of what's in Jug 2 and what Jug 1 can hold
        pour_amount = min(jug2, jug1_cap - jug1)
        next_jug1 = jug1 + pour_amount
        next_jug2 = jug2 - pour_amount
        next_state = (next_jug1, next_jug2)
        if next_state not in visited:
            visited.add(next_state)
            new_path = path + [next_state]
            queue.append((next_state, new_path))

    # If the queue is empty and the goal wasn't reached, it's impossible
    return None

# --- Example Usage ---

# Jug A has a capacity of 4 gallons, Jug B has a capacity of 3 gallons.
# Goal is to measure exactly 2 gallons.
JUG_A_CAPACITY = 4
JUG_B_CAPACITY = 3
TARGET_AMOUNT = 2

solution = water_jug_solver(JUG_A_CAPACITY, JUG_B_CAPACITY, TARGET_AMOUNT)

print(f"--- Water Jug Problem Solution (Goal: {TARGET_AMOUNT} gallons) ---")
print(f"Jug Capacities: Jug A ({JUG_A_CAPACITY} gal), Jug B ({JUG_B_CAPACITY} gal)")

if solution:
    print("\n✅ Shortest Path Found (States: (Jug A, Jug B)):")
    for i, state in enumerate(solution):
        # Determine the action taken to get to the current state (except for the start)
        action_desc = ""
        if i > 0:
            prev_state = solution[i-1]
            # Simple text description (can be made more detailed)
            if state[0] > prev_state[0] and state[1] == prev_state[1] and state[0] == JUG_A_CAPACITY:
                action_desc = "Fill Jug A"
            elif state[0] == prev_state[0] and state[1] > prev_state[1] and state[1] == JUG_B_CAPACITY:
                action_desc = "Fill Jug B"
            elif state[0] < prev_state[0] and state[1] == prev_state[1] and state[0] == 0:
                action_desc = "Empty Jug A"
            elif state[0] == prev_state[0] and state[1] < prev_state[1] and state[1] == 0:
                action_desc = "Empty Jug B"
            elif state[0] < prev_state[0] and state[1] > prev_state[1]:
                action_desc = "Pour A to B"
            elif state[0] > prev_state[0] and state[1] < prev_state[1]:
                action_desc = "Pour B to A"
            else:
                action_desc = "Start"

            print(f"Step {i}: {state}  <-- Action: {action_desc}")
        else:
            print(f"Step {i}: {state}  <-- Action: Start")

else:
    print("\n❌ The target amount is **unreachable** with these jug capacities.")

"""That's a great set of reflection questions for analyzing search algorithms like Breadth-First Search (BFS), Depth-First Search (DFS), and A Search* in the context of problems like the Water Jug Problem.

Here are the answers comparing the three algorithms:

1. Comparing the Solution Paths
Algorithm	Path Characteristic	Example Path (Water Jug)
BFS	Shortest/Optimal in terms of number of steps (edges).	Finds the path with the minimum number of pours/fills/empties.
DFS	Can be long and sub-optimal. Finds the first path it encounters by diving deep.	Might explore a very long sequence of steps that is not the most direct route to the target.
A*	Shortest/Optimal in terms of path cost (if the heuristic is admissible and consistent).	Finds the path with the minimum number of steps, identical to BFS if the step cost is uniform.

Export to Sheets
In the Water Jug Problem, where every step (fill, empty, pour) has a uniform cost (cost = 1), the path found by BFS and A* (using a simple admissible heuristic like h(n)=0 or h(n)=target amount−current max amount) will be the same shortest path. DFS, however, is prone to finding a much longer, non-optimal path because it explores deeply before backtracking.

2. Which Algorithm Gives the Shortest Path? Why?
The algorithms that guarantee the shortest path for the Water Jug Problem are BFS and A* Search (assuming a non-misleading, admissible heuristic).

Breadth-First Search (BFS):

Why: BFS explores all nodes at a given depth level before moving to the next level. Since every step (edge) has the same cost (1), the first time it reaches the goal state, it must be via the path with the fewest steps. It is complete and optimal for unweighted graphs (uniform step costs).

A* Search:

Why: A* uses the evaluation function f(n)=g(n)+h(n), where g(n) is the actual path cost from the start (number of steps) and h(n) is the estimated cost to the goal (heuristic). When the heuristic h(n) is admissible (never overestimates the cost) and the step cost is uniform, A* is also optimal and finds the shortest path.

DFS is not guaranteed to find the shortest path, as it might go down a very long branch that eventually leads to the goal before ever exploring a shorter branch.

3. Which Algorithm is More Efficient in Terms of Time and Memory?
The efficiency comparison depends heavily on the structure of the search space (which, for the Water Jug problem, is small and finite).

Metric	BFS	DFS	A* Search
Time Efficiency (Worst Case)	O(b
d
 ) (where b is branching factor, d is depth of the solution)	O(b
m
 ) (where m is max depth of search space)	Better than BFS (if heuristic is good)
Memory Efficiency	Poor (Stores all generated nodes in the queue)	Excellent (Stores only the current path)	Poor (Stores all generated nodes in the priority queue)

Export to Sheets
Time Efficiency (Speed):

A* is generally the most time-efficient because the heuristic guides the search toward the goal, avoiding the exploration of large, irrelevant parts of the state space that BFS would waste time on.

BFS is complete but can be slow because it explores all directions equally until the goal is found.

DFS can be very fast if it happens to guess the right path early, but it can be extremely slow if it explores a very deep dead-end first.

Memory Efficiency (Space):

DFS is the most memory-efficient because it only needs to store the nodes on the current path being explored. Its memory requirement is proportional to the depth of the search space (O(d)).

BFS and A* are generally memory-intensive because they must store every node that has been generated in their respective queues (standard queue for BFS, priority queue for A*) to ensure optimality and proper exploration. Their memory requirement is proportional to the size of the search space (O(b
d
 )).
"""